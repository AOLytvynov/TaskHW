# TaskHW

## Prototype

Тип шаблону: Creational pattern  
Призначення: Створює нові об'єкти шляхом копіювання вже існуючих (прототипів), замість використання new.  
Опис:  
Prototype — це компонент архітектурного рівня, що реалізує механізм створення нових об’єктів шляхом копіювання вже існуючих. Замість того, щоб створювати об’єкти через new, клієнт отримує клон вже існуючого зразка.  
Шаблон Prototype доцільно застосовувати у наступних випадках:  
- Коли створення об’єкта є ресурсоємним або потребує складної конфігурації (наприклад, при читанні з бази даних, генерації на основі великої кількості параметрів).  
- Коли необхідно уникнути залежності від конкретного класу під час створення нових об'єктів.  
- Коли потрібно динамічно створювати об'єкти, типи яких визначаються під час виконання програми.  
- У випадках, коли існує встановлений набір стандартних об'єктів-прототипів, які можуть слугувати основою для створення нових екземплярів.  
- У редакторах, конструкторах інтерфейсів, ігрових рушіях, де користувач або система створює нові елементи на основі заздалегідь визначених шаблонів.  
Застосування шаблону Prototype дозволяє зменшити кількість дубльованого коду, спростити структуру створення об’єктів та підвищити масштабованість програмного продукту.  
  
Основні структурні елементи:  
1. IPrototype - Інтерфейс, що оголошує метод Clone(), який повинен реалізовуватись усіма конкретними прототипами. Метод Clone() відповідає за створення копії об’єкта.  
2. ConcretePrototype - Конкретна реалізація інтерфейсу IPrototype, що містить поля даних (наприклад, field1, field2) та реалізує метод Clone(). Метод повертає новий об’єкт з такими ж значеннями полів.  
3. Client - Клас, який використовує прототипи для створення нових об’єктів. Він не створює об'єкти напряму через new, а викликає метод Clone() на існуючих екземплярах. Це дозволяє зменшити залежність від конкретних класів.  
  
Статичну діаграму класів для шаблону Prototype зображено на рисунку 1.  

![](assets/Prototype%20-%20статична.png)

Рисунок 1 - Статична діаграма класів для шаблону Prototype.

Діаграму взаємодії у шаблоні Prototype зображено на рисунку 2.

![](assets/Prototype%20-%20динамічна.png)

Рисунок 2 - Діаграма взаємодії у шаблоні Prototype.

## Composite

Тип шаблону: Structural pattern  
Призначення: Дозволяє об'єднувати об'єкти у деревоподібну структуру та працювати з окремими об’єктами та їх групами однаково.  
Опис:  
Composite — це структурний шаблон проєктування, який дозволяє створювати ієрархічні структури об'єктів, де одиничні об’єкти і групи об’єктів обробляються однаковим чином. Завдяки цьому шаблону клієнтський код може працювати з усіма об'єктами через один інтерфейс, не знаючи, з чим саме він має справу.  
Шаблон Composite доцільно застосовувати у наступних випадках:  
- Коли потрібно представляти частково-цілісні ієрархії (наприклад, дерево UI-елементів, файлову систему, організаційну структуру).
- Коли клієнтам необхідно однаково взаємодіяти з простими та складеними об'єктами.
- Коли важливо мати можливість рекурсивно обробляти структуру без дублювання коду.
- У випадках, коли система має рекурсивну природу, тобто коли компоненти можуть містити інші компоненти того ж типу.
Застосування шаблону Composite дозволяє зменшити залежність клієнтського коду від конкретних типів об'єктів, уніфікує взаємодію з елементами і дає змогу гнучко модифікувати структуру без зміни логіки її обробки.  
  
Основні структурні елементи:  
1. Component - Абстрактний клас або інтерфейс, який описує загальні операції як для простих, так і для складених об’єктів. Наприклад, методи Add(), Remove(), Display().
2. Leaf - Конкретна реалізація Component, яка представляє окремі (атомарні) об'єкти. Вони не мають дочірніх елементів і реалізують логіку базових операцій.
3. Composite - Клас, який також реалізує Component, але містить колекцію інших об'єктів-компонентів. Цей клас реалізує логіку керування колекцією дочірніх елементів.
4. Client - Клас або модуль, який працює з усіма об’єктами через інтерфейс Component, не роблячи відмінностей між Leaf і Composite.

Статичну діаграму класів для шаблону Composite зображено на рисунку 3.

![](assets/Composite%20-%20статична.png)

Рисунок 3 - Статична діаграма класів для шаблону Composite.

Діаграму взаємодії у шаблоні Composite зображено на рисунку 4.

![](assets/Composite%20-%20динамічна.png)

Рисунок 4 - Діаграма взаємодії у шаблоні Composite.

## Null Object

Тип шаблону: Behavioral pattern  
Призначення: Уникає перевірок на null, надаючи об'єкт, який поводиться як "порожній", але реалізує очікувану поведінку.  
Опис:  
Null Object — це поведінковий шаблон проєктування, який пропонує використовувати спеціальний об’єкт-пустушку замість null. Такий об’єкт реалізує інтерфейс або базовий клас, але не виконує жодних дій або забезпечує нейтральну поведінку, яка не впливає на логіку програми.  
Завдяки цьому шаблону усувається необхідність у перевірках на null, а також знижується ризик помилок, пов'язаних із відсутністю об'єкта (наприклад, NullReferenceException).  
Шаблон Null Object доцільно застосовувати у наступних випадках:  
- Коли у програмі часто трапляється ситуація, коли об'єкт може бути відсутнім (null).
- Коли бажано, щоб у відсутності конкретного об'єкта все одно була доступна деяка безпечна за замовчуванням поведінка.
- Коли потрібно спростити клієнтський код, усунувши перевірки на null перед кожним викликом методу.
- У системах логування, безпечного виводу, шаблонах команд, коли "нічого не робити" — це теж поведінка.
Застосування шаблону Null Object дозволяє створювати гнучкіші, чистіші та більш надійні системи, де поведінка об'єктів є уніфікованою незалежно від їх реальної "наявності".  
  
Основні структурні елементи:
1. AbstractObject (інтерфейс або абстрактний клас) - Визначає загальний інтерфейс для реального об'єкта та об’єкта-пустушки. Наприклад, метод Execute() або Log().
2. RealObject - Конкретна реалізація AbstractObject, яка виконує реальну корисну дію — наприклад, обробляє запит, виконує команду, або записує у лог.
3. NullObject - Конкретна реалізація AbstractObject, яка не робить нічого або виконує нейтральну дію. Вона замінює null, дозволяючи клієнтському коду викликати методи без перевірок.
4. Client - Клас, який використовує об’єкти через інтерфейс AbstractObject, не знаючи, чи працює з реальним об’єктом, чи з об’єктом-пустушкою. Це дозволяє однакове використання і реальних об'єктів, і NullObject, без додаткових умов.

Статичну діаграму класів для шаблону Null Object зображено на рисунку 5.

![](assets/Null%20Object%20-%20статична.png)

Рисунок 5 - Статична діаграма класів для шаблону Null Object.

Діаграму взаємодії у шаблоні Null Object зображено на рисунку 6.

![](assets/Null%20Object%20-%20динамічна.png)

Рисунок 6 - Діаграма взаємодії у шаблоні Null Object.

## Monitor Object

Тип шаблону: Concurrency pattern  
Призначення: Забезпечує синхронізований доступ до об’єкта з кількох потоків, інкапсулюючи механізм блокування всередині самого об’єкта.  
Опис:  
Monitor Object — це шаблон паралельного програмування, який дозволяє безпечно виконувати одночасний доступ до об’єкта з кількох потоків, забезпечуючи автоматичне управління синхронізацією.  
Ідея полягає в тому, що всі методи об’єкта є критичними секціями, тобто їх виконання дозволено лише одному потоку одночасно. Синхронізація виконується всередині самого об'єкта, і клієнтський код не повинен явно керувати блокуваннями.  
Завдяки шаблону Monitor Object забезпечується інкапсуляція синхронізації, що зменшує ризик помилок при роботі з потоками, таких як deadlock, race condition або неконсистентність даних.  
Шаблон Monitor Object доцільно застосовувати у наступних випадках:
- Коли об’єкт використовується одночасно з кількох потоків і вимагає захисту спільних ресурсів.
- Коли потрібно ізолювати логіку синхронізації всередині самого класу.
- Коли бажано, щоб багатопотокова взаємодія залишалась прозорою для клієнта.
Застосування шаблону Monitor Object дозволяє створювати надійні та безпечні багатопотокові компоненти, де синхронізація відбувається автоматично, без участі клієнтського коду.

Основні структурні елементи:
1. MonitorObject - Клас, який містить критичну логіку або ресурси, доступ до яких потребує синхронізації. Всі методи, що змінюють або читають ці ресурси, заблоковані синхронізуючими механізмами.
2. Lock/Mutex - Об'єкт або конструкція, яка забезпечує виконання лише одного потоку всередині методів MonitorObject одночасно. Цей механізм не видно клієнту, оскільки він повністю інкапсульований.
3. Client - Потоки або зовнішній код, які звертаються до методів MonitorObject без потреби явно управляти синхронізацією. Monitor Object гарантує безпечне виконання навіть при одночасному доступі.


Статичну діаграму класів для шаблону Monitor Object зображено на рисунку 7.

![](assets/Monitor%20Object%20-%20статична.png)

Рисунок 7 - Статична діаграма класів для шаблону Monitor Object.

Діаграму взаємодії у шаблоні Monitor Object зображено на рисунку 8.

![](assets/Monitor%20Object%20-%20динамічна.png)

Рисунок 8 - Діаграма взаємодії у шаблоні Monitor Object.
